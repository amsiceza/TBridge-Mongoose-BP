# SOCIAL NETWORK - PROYECTO BACKEND (MONGOOSE)

En este proyecto encontramos una base de datos no relacional que simula una red social. Los datos que almacenamos dentro de esta base de datos son:
- Usuarios.
- Post.
- Comentarios.
- Implementaci√≥n de likes.
- Implementaci√≥n de followers.


## Comenzando üöÄ

Para poder desplegar el proyecto correctamente, desde GitHub y con el acceso correspondiente al repositorio de la web, clonar el repositorio en su ordenador, tambi√©n deber√° instalar todas las herramientas, frameworks, y los middlewares para el funcionamiento correcto.

## Ejecutando Node ‚å®Ô∏è
Node es un entorno de ejecuci√≥n de JavaScript orientado a eventos as√≠ncronos. Node.js est√° dise√±ado para crear aplicaciones network escalables.

- Node.js es un entorno de servidor de c√≥digo abierto.
- Node.js es gratis.
- Node.js se ejecuta en varias plataformas (Windows, Linux, Unix, Mac OS X, etc.)
- Node.js usa JavaScript en el servidor.

Lo descargamos del siguiente enlace [*NODE*](https://nodejs.org/es/).

### Instalaci√≥n Nodemon:
Nodemon es una herramienta que ayuda a desarrollar aplicaciones basadas en node.js al reiniciar autom√°ticamente la aplicaci√≥n cuando se detectan cambios en los archivos del directorio.

‚óè npm install -D nodemon.


## Ejecutando Express ‚å®Ô∏è
Un framework como Express, es un patr√≥n o esquema que ayuda a la programaci√≥n a estructurar el c√≥digo y a ahorrar tiempo y
esfuerzos a los programadores. Express.js es un framework de Node.js y permite crear una API robusta r√°pido y f√°cil.

‚óè npm install express.


## Instalando Postman ‚å®Ô∏è
Postman es una herramienta que sirve de gran ayuda al equipo de desarrollo, permitiendo mantener las colecciones actualizadas, ahorrando los tiempos de respuesta al momento de realizar los test o las llamadas a los servicios.

Postman sirve para m√∫ltiples tareas dentro de las cuales destacaremos en esta oportunidad las siguientes:

- Testear colecciones o cat√°logos de APIs tanto para Frontend como para Backend.
- Organizar en carpetas, funcionalidades y m√≥dulos los servicios web.
- Permite gestionar el ciclo de vida (conceptualizaci√≥n y definici√≥n, desarrollo, monitoreo y mantenimiento) de nuestra API.
- Generar documentaci√≥n de nuestras APIs.
- Trabajar con entornos (calidad, desarrollo, producci√≥n) y de este modo es posible compartir a trav√©s de un entorno cloud la informaci√≥n con   el resto del equipo involucrado en el desarrollo.

Lo descargamos del siguiente enlace [*POSTMAN*](https://www.postman.com/downloads/).

## Ejecutando Sequelize ‚å®Ô∏è

Sequelize es un ORM O(Object) R (Relational) M(Mapping) que permite a los usuarios llamar a funciones javascript para interactuar con SQL DB sin escribir consultas reales. Es bastante √∫til para acelerar el tiempo de desarrollo.

Primero instalamos el CLI de Sequelize de forma global (solo se hace una vez en tu PC).

‚óè npm install sequelize-cli -g.

Para las veces posteriores, instalaremos varias herramientas de forma simult√°nea.

‚óè npm install express sequelize mysql2.

## Ejecutando Mongoose ‚å®Ô∏è
FALTA A√ëADIR!!!!!!!!!!!!!!!!
## Ejecutando Swagger ‚å®Ô∏è
FALTA A√ëADIR!!!!!!!!!!!!!!!!

## EXTRAS ‚å®Ô∏è

### BCRYPT (Encriptaci√≥n de contrase√±as) üñ≥

HASH --> Una funci√≥n criptogr√°fica hash- usualmente conocida como ‚Äúhash‚Äù- es un algoritmo matem√°tico que transforma cualquier
bloque arbitrario de datos en una nueva serie de caracteres con una longitud fija.

SALT --> Un salt es una string aleatoria. Al encriptar una contrase√±a de texto sin formato m√°s un salt, la salida del
algoritmo hash ya no es predecible. La misma contrase√±a ya no producir√° el mismo hash.

‚óè npm i bcryptjs


>Ejemplo de importaci√≥n del m√≥dulo bcrypt:
```js
const { User, Post } = require('../models/index.js');
const bcrypt = require ('bcryptjs');
const UserController = {
    create(req, res) {
    req.body.role = "user";
const password = bcrypt.hashSync(req.body.password,10)
    User.create({...req.body, password:password })
    .then(user => res.status(201).send({ message: 'Usuario creado con √©xito', user }))
    .catch(err => console.error(err))
},}
```
>Creando ejemplo de login de la siguiente forma con bcrypt:
```js
const UserController = {
    login(req,res){
    User.findOne({
        where:{
        email:req.body.email
        }
    }).then(user=>{
    if(!user){
    return res.status(400).send({message:"Usuario o contrase√±a incorrectos"})
    }
    const isMatch = bcrypt.compareSync(req.body.password, user.password);
    if(!isMatch){
    return res.status(400).send({message:"Usuario o contrase√±a incorrectos"})
    }
    res.send(user)
    })
},}
```

### JWT JSON Web Token üñ≥

JWT se crea con una clave secreta y esa clave secreta es privada para ti (tu servidor), lo que significa que nunca se revelar√° al p√∫blico ni se inyectar√° dentro del token JWT. Cuando recibe un JWT del cliente, puede verificar ese JWT con esta clave secreta almacenada en el servidor.

‚óè npm i jsonwebtoken


>Ejemplo de generar e importar el modelo Token:
```js
const { User, Post } = require('../models/index.js');
const bcrypt = require ('bcryptjs');
const jwt = require('jsonwebtoken');
const { jwt_secret } = require('../config/config.json')['development']
const UserController = {
    login(req,res){
        User.findOne({
        where:{
        email:req.body.email
        }
        }).then(user=>{
    if(!user){
    return res.status(400).send({message:"Usuario o contrase√±a incorrectos"})
    }
const isMatch = bcrypt.compareSync(req.body.password, user.password);
    if(!isMatch){
    return res.status(400).send({message:"Usuario o contrase√±a incorrectos"})
    }
let token = jwt.sign({ id: user.id }, jwt_secret);
Token.create({ token, UserId: user.id });
res.send({ message: 'Bienvenid@' + user.name, user, token });
})
 } 
 }
```
### Authentication middleware üñ≥

- Tenemos definida una ruta a la cual solo usuarios logeados pueden entrar, por lo tanto, se necesita comprobar antes de entrar a esa ruta, si el usuario est√° o no logeado.

- Creamos una carpeta middleware y dentro de ella un archivo que se llame authentication.js que contendr√° el siguiente c√≥digo:

>Middleware de autenticaci√≥n:
```js
const { User, Token, Sequelize } = require('../models');
const { Op } = Sequelize;
const jwt = require('jsonwebtoken');
const {jwt_secret} = require('../config/config.json')['development']
const authentication = async(req, res, next) => {
    try {
    const token = req.headers.authorization;
    const payload = jwt.verify(token, jwt_secret);
    const user = await User.findByPk(payload.id);
    const tokenFound = await Token.findOne({
        where: {
        [Op.and]: [
            { UserId: user.id },
            { token: token }
        ]
        }
    });
    if (!tokenFound) {
    return res.status(401).send({ message: 'No estas autorizado' });
    }
    req.user = user;
    next();
    } catch (error) {
    console.log(error)
    res.status(500).send({ error, message: 'Ha habido un problema con el token' })
    }
}
module.exports = { authentication }
```
>Ejemplo de implementaci√≥n:
```js
const express = require('express');
const router = express.Router();
const UserController = require('../controllers/UserController')
const {authentication} = require('../middleware/authentication')
router.post('/',UserController.create)
router.get('/',authentication,UserController.getAll)
router.delete('/:id',authentication,UserController.delete)
router.put('/:id',authentication,UserController.update)
router.post('/login',UserController.login)
module.exports = router;
```
### isAdmin Middleware üñ≥

- Tenemos definida una ruta a la cual solo usuarios administradores pueden ingresar, por lo tanto, se necesita comprobar antes de entrar a esa ruta, si el usuario es o no, un administrador.

- Ahora crearemos un middleware que chequeara el rol del usuario para saber si es admin, lo a√±adimos al c√≥digo de autentication:

>Middleware de admin:
```js
const isAdmin = async(req, res, next) => {
const admins = ['admin','superadmin'];
    if (!admins.includes(req.user.role)) {
    return res.status(403).send({
    message: 'No tienes permisos'
});
}
next();
}
module.exports = { authentication, isAdmin }
```
### Nodemailer üñ≥

- Nodemailer es un m√≥dulo para aplicaciones Node.js que permite enviar correos electr√≥nicos de
forma sencilla. Para instalarlo ejecutamos el siguiente comando:

- npm install nodemailer

- Creamos un archivo nodemailer.js en la carpeta config donde se guardar√° la siguiente configuraci√≥n:

>Ejemplo de nodemailer:
```js
const nodemailer = require('nodemailer');
let transporter = nodemailer.createTransport({
    host: 'smtp.gmail.com',
    port: 465,
    secure: true,
    auth: {
        user: 'tuemail@gmail.com',
        pass: '123456'
    }
});
module.exports = transporter;
```
>Ejemplo para importar el m√≥dulo nodemailer:
```js
const transporter = require("../config/nodemailer");
. . .
async create(req, res, next) {
    try {
    const hash = bcrypt.hashSync(req.body.password, 10);
    const user = await User.create({
        ...req.body,
        password: hash,
        confirmed: false,
        rol: "user",
    });
await transporter.sendMail({
    to: req.body.email,
    subject: "Confirme su registro",
    html: `<h3>Bienvenido, est√°s a un paso de registrarte </h3>
    <a href="#"> Click para confirmar tu registro</a>
    `,
});
res.status(201).send({
    message: "Te hemos enviado un correo para confirmar el registro",
    user,
});
} catch (err) {
    err.origin = ‚ÄúUser‚Äù;
    next(err)
}
},
```
- Ahora crearemos un endpoint en nuestro UserController que nos confirme el usuario:

>Confirmaci√≥n de usuario:
```js
async confirm(req,res){
    try {
        await User.update({confirmed:true},{
            where:{
            email: req.params.email
        }
    })
res.status(201).send( "Usuario confirmado con √©xito" );
    } catch (error) {
        console.error(error)
    }
},
```
### Middleware errors üñ≥

- Ahora vamos a crear un middleware que nos va a permitir controlar los errores a la hora de crear un elemento nuevo.

- Vamos a introducir cambios en la parte del manejo del error en el controlador UserController (catch), para ello necesitamos utilizar el par√°metro ‚Äúnext‚Äù y pasarle el error que tenemos capturado. Tambi√©n vamos a modificar el error a√±adiendo una nueva propiedad ‚Äúorigin‚Äù.

>Actualizaci√≥n del controlador:
```js
async create(req, res,next) {
    try {
        req.body.role = "user";
        const password = await bcrypt.hash(req.body.password, 10);
        const user = await User.create({ ...req.body, password });
        res.send(user);
    } catch (error) {
        console.error(error)
        next(error)
    }
},
```
- En la carpeta ‚Äúmiddlewares‚Äù creamos un archivo llamado ‚Äúerrors.js‚Äù.

>Middleware de errores:
```js
const handleValidationError = (err, res) => {
    let errors = err.errors.map((el) => el.message);
    if (errors.length > 1) {
        const msgErr = errors.join(" || ");
        res.status(400).send({ messages: msgErr });
    } else {
        res.status(400).send({ messages: errors });
    }
};
const typeError = (err, req, res, next) => {
    if (
        err.name === "SequelizeValidationError" ||
        err.name === "SequelizeUniqueConstraintError"
    ) {
        handleValidationError(err, res);
    } else {
        res.status(500).send({ msg: "Hubo un problema",err });
    }
};
module.exports = { typeError };
```
### MULTER (Inserci√≥n de files (im√°genes) en los endpoints) üñ≥
FALTA A√ëADIR!!!!!!!!!!!!!!!!

## Construido con üõ†Ô∏è

_Menciona las herramientas que utilizaste para crear tu proyecto_

* [*VISUAL STUDIO CODE*](https://code.visualstudio.com/) - Code editor used (Version: 1.75.1)
* [*Live Server*](https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer) - Manejador de dependencias
* [*GitHub*](https://github.com/) - Almacenamiento de repositorios
* [*NODE*](https://nodejs.org/es/) - Entorno de ejecuci√≥n de JavaScript en el servidor
* [*POSTMAN*](https://www.postman.com/) - Herramienta para testear las API
* [*Mongo DB*](https://www.mongodb.com/) - Herramienta para crear y gestionar bases de datos NoSQL orientada a documentos
* [*Mongo Atlas*](https://www.mongodb.com/atlas/database) - MongoDB Atlas es una DaaS (Base de datos como servicio) de MongoDB
* [*Swagger*](https://swagger.io/) - Herramienta  para dise√±ar, construir, documentar y probar tu API.


## Versionado üìå

Usamos [SemVer](http://semver.org/) para el versionado. Para todas las versiones disponibles, mira los [tags en este repositorio](https://github.com/GuilleSoler87/Quiz_JavaScript.git).

## Autores ‚úíÔ∏è

* **Guillermo Soler Fern√°ndez** - *Proyecto API Backend - Mongoose-Node-Express* - [GuilleSoler87](https://github.com/GuilleSoler87)
* **Ismael Cervera Zamora** - *Proyecto API Backend - Mongoose-Node-Express* - [amsiceza](https://github.com/amsiceza)
  


## Licencia üìÑ

Este proyecto actualmente no tiene licencia. Puede usarse todo su contenido sin el requisito de la misma.